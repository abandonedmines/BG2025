<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>GeoJSON 자동 로딩 지도</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; }
    #map { width: 100%; height: 100vh; }
  </style>
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=9e36db09e57011893c10d8a46f344a7f&autoload=false"></script>
</head>
<body>
  <div id="map"></div>

  <script>
    kakao.maps.load(function () {
      const map = new kakao.maps.Map(document.getElementById('map'), {
        center: new kakao.maps.LatLng(36.460980, 127.615083),
        level: 4,
        mapTypeId: kakao.maps.MapTypeId.HYBRID
      });

      const geojsonFiles = [
        { file: 'samplingresult_1st.geojson', layerType: 'sampling' },
        { file: 'BG_boundary.geojson', layerType: 'boundary' },
        { file: 'BG_mainflowline.geojson', layerType: 'mainflow' }
      ];

      geojsonFiles.forEach(({ file, layerType }) => {
        fetch(file)
          .then(res => res.json())
          .then(data => {
            console.log(`✅ ${file} 로드 완료`);
            drawGeoJSON(data, layerType);
          })
          .catch(err => console.error(`❌ ${file} 로드 실패:`, err));
      });

      let openInfoWindow = null; // ✅ InfoWindow 추적 변수

      function drawGeoJSON(geojson, type = 'default') {
        geojson.features.forEach(feature => {
          const geomType = feature.geometry.type;
          const coords = feature.geometry.coordinates;

          if (geomType === 'Polygon' || geomType === 'MultiPolygon') {
            const polygons = geomType === 'Polygon' ? [coords] : coords;
            polygons.forEach(polygon => {
              polygon.forEach(ring => {
                const path = ring.map(([lng, lat]) => new kakao.maps.LatLng(lat, lng));
                const style = getPolygonStyle(type);

                new kakao.maps.Polygon({
                  path: path,
                  strokeWeight: style.strokeWeight,
                  strokeColor: style.strokeColor,
                  strokeStyle: style.strokeStyle,
                  fillColor: style.fillColor,
                  fillOpacity: style.fillOpacity
                }).setMap(map);
              });
            });
          }

          if (geomType === 'LineString') {
            const path = coords.map(([lng, lat]) => new kakao.maps.LatLng(lat, lng));
            const style = getLineStyle(type);

            new kakao.maps.Polyline({
              path: path,
              strokeWeight: style.strokeWeight,
              strokeColor: style.strokeColor,
              strokeOpacity: style.strokeOpacity
            }).setMap(map);
          }

          if (geomType === 'Point') {
            const [lng, lat] = coords;
            const pointPos = new kakao.maps.LatLng(lat, lng);

            if (type === 'sampling') {
              const id = feature.properties?.name;
              const photo = feature.properties?.photo_url;

              const marker = new kakao.maps.Marker({ position: pointPos });
              marker.setMap(map);

              if (id) {
                const label = new kakao.maps.CustomOverlay({
                  position: pointPos,
                  content: `
                    <div style="
                      background:white;
                      border:2px solid #888;
                      padding:4px 8px;
                      border-radius:6px;
                      font-size:16px;
                      font-weight: bold;
                      transform: translate(10px, -35px);
                      pointer-events: none;
                      box-shadow: 2px 2px 6px rgba(0,0,0,0.2);
                    ">
                      ${id}
                    </div>`,
                  xAnchor: 0,
                  yAnchor: 1
                });
                label.setMap(map);
              }

              if (photo) {
                const infowindow = new kakao.maps.InfoWindow({
                  content: `<div style="padding:5px;"><strong>${id || ''}</strong><br><img src="${photo}" width="400"/></div>`
                });

                kakao.maps.event.addListener(marker, 'click', function () {
                  if (openInfoWindow) {
                    openInfoWindow.close();
                  }
                  infowindow.open(map, marker);
                  openInfoWindow = infowindow;
                });
              }
            } else {
              new kakao.maps.Marker({ position: pointPos }).setMap(map);
            }
          }
        });
      }

      // ✅ 지도 클릭 시 열린 InfoWindow 닫기
      kakao.maps.event.addListener(map, 'click', function () {
        if (openInfoWindow) {
          openInfoWindow.close();
          openInfoWindow = null;
        }
      });

      function getPolygonStyle(type) {
        if (type === 'boundary') {
          return {
            strokeWeight: 2,
            strokeColor: '#FFFF00',
            strokeStyle: 'dash',
            fillColor: 'rgba(0,0,0,0)',
            fillOpacity: 0
          };
        }
        return {
          strokeWeight: 2,
          strokeColor: '#333',
          strokeStyle: 'solid',
          fillColor: '#cccccc',
          fillOpacity: 0.3
        };
      }

      function getLineStyle(type) {
        if (type === 'mainflow') {
          return {
            strokeWeight: 3,
            strokeColor: '#0000FF',
            strokeOpacity: 0.8
          };
        }
        return {
          strokeWeight: 2,
          strokeColor: '#444',
          strokeOpacity: 0.5
        };
      }
    });
  </script>
</body>
</html>
