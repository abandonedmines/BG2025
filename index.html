<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>GeoJSON 자동 로딩 지도</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; }
    #map { width: 100%; height: 100vh; }
  </style>
  <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=9e36db09e57011893c10d8a46f344a7f&autoload=false"></script>
</head>
<body>
  <div id="map"></div>

  <script>
    kakao.maps.load(function () {
      const map = new kakao.maps.Map(document.getElementById('map'), {
        center: new kakao.maps.LatLng(36.460980, 127.615083),
        level: 4,
        mapTypeId: kakao.maps.MapTypeId.HYBRID
      });

      // ✅ GeoJSON 파일 배열
      const geojsonFiles = [
        { file: 'samplingresult_1st.geojson', layerType: 'sampling' },
        { file: 'BG_boundary.geojson', layerType: 'boundary' }
      ];

      // ✅ 각 파일 fetch 후 스타일 적용
      geojsonFiles.forEach(({ file, layerType }) => {
        fetch(file)
          .then(res => res.json())
          .then(data => {
            console.log(`✅ ${file} 로드 완료`);
            drawGeoJSON(data, layerType);
          })
          .catch(err => console.error(`❌ ${file} 로드 실패:`, err));
      });

      // ✅ GeoJSON 시각화 함수
      function drawGeoJSON(geojson, type = 'default') {
        geojson.features.forEach(feature => {
          const geomType = feature.geometry.type;
          const coords = feature.geometry.coordinates;

          if (geomType === 'Polygon' || geomType === 'MultiPolygon') {
            const polygons = geomType === 'Polygon' ? [coords] : coords;
            polygons.forEach(polygon => {
              polygon.forEach(ring => {
                const path = ring.map(([lng, lat]) => new kakao.maps.LatLng(lat, lng));
                const style = getPolygonStyle(type);

                new kakao.maps.Polygon({
                  path: path,
                  strokeWeight: style.strokeWeight,
                  strokeColor: style.strokeColor,
                  strokeStyle: style.strokeStyle,
                  fillColor: style.fillColor,
                  fillOpacity: style.fillOpacity
                }).setMap(map);
              });
            });
          }

          if (geomType === 'LineString') {
            const path = coords.map(([lng, lat]) => new kakao.maps.LatLng(lat, lng));
            const style = getLineStyle(type);

            new kakao.maps.Polyline({
              path: path,
              strokeWeight: style.strokeWeight,
              strokeColor: style.strokeColor,
              strokeOpacity: style.strokeOpacity
            }).setMap(map);
          }

          if (geomType === 'Point') {
            const [lng, lat] = coords;
            const pointPos = new kakao.maps.LatLng(lat, lng);

            if (type === 'sampling') {
              const id = feature.properties?.name;
              const photo = feature.properties?.photo_url;

              // ✅ 마커 생성
              const marker = new kakao.maps.Marker({ position: pointPos });
              marker.setMap(map);

              // ✅ 라벨 중복 없이 한 번만 생성
              if (id) {
                const label = new kakao.maps.CustomOverlay({
                  position: pointPos,
                  content: `<div style="background:white;border:1px solid #888;padding:2px 5px;border-radius:4px;font-size:12px;">${id}</div>`,
                  margin-left: 10px
                });
                label.setMap(map);
              }

              // ✅ 사진이 있을 경우 InfoWindow 연결
              if (photo) {
                const infowindow = new kakao.maps.InfoWindow({
                  content: `<div style="padding:5px;"><strong>${id || ''}</strong><br><img src="${photo}" width="200"/></div>`
                });
                kakao.maps.event.addListener(marker, 'click', function () {
                  infowindow.open(map, marker);
                });
              }

            } else {
              new kakao.maps.Marker({ position: pointPos }).setMap(map);
            }
          }
        });
      }

      // ✅ Polygon 스타일 함수
      function getPolygonStyle(type) {
        if (type === 'boundary') {
          return {
            strokeWeight: 2,
            strokeColor: '#FFFF00',
            strokeStyle: 'dash',
            fillColor: 'rgba(0,0,0,0)',
            fillOpacity: 0
          };
        }
        return {
          strokeWeight: 2,
          strokeColor: '#333',
          strokeStyle: 'solid',
          fillColor: '#cccccc',
          fillOpacity: 0.3
        };
      }

      // ✅ Line 스타일 함수
      function getLineStyle(type) {
        if (type === 'river') {
          return {
            strokeWeight: 2,
            strokeColor: '#0000FF',
            strokeOpacity: 0.8
          };
        }
        return {
          strokeWeight: 2,
          strokeColor: '#444',
          strokeOpacity: 0.5
        };
      }
    });
  </script>
</body>
</html>
